(define (list-def items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
;; (define (length items)
;;   (if (null? items)
;;       0
;;       (+ 1 (length (cdr items)))))
(define (length items)
  (define (length-iter a counter)
    (if (null? a)
	counter
	(length-iter (cdr a) (+ counter 1))))
  (length-iter items 0))
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
;;;2.17
;(define (list-pair list)
 ; (if (not (null? list))
;      (list-ref list (- (length list) 1)))
(define (last-pair list)
  (cond ((null? list)
	  (error "list-empty--lastpair" list))
	 ((null? (cdr list))
	  list)
	 (else
	  (last-pair (cdr list)))))
;;;2.18
(define (reverse list)
  (define (reverse-iter remained-items result)
    (if (null? remained-items)
	result
	(reverse-iter (cdr remained-items) 
		      (cons (car remained-items) result))))
  (reverse-iter list '()))
;;;;;2.19
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
(define (cc amount coin-values)
  (define (no-more? a) (null? a))
  (define (except-first-demonination list) (cdr list))
  (define (first-demonination list) (car list))
  (cond  ((= amount 0) 1)
	  ((or (< amount 0) (no-more? coin-values)) 0)
	  (else
	   (+ (cc amount
		  (except-first-demonination coin-values))
	      (cc (- amount
		    (first-demonination coin-values))
		  coin-values)))))
;;;2.20
(define (same-pairy x . y)
  (if (null? y)
      '()
       (filter (if (even? x)
	      even?
	      odd?)
	      (cons x y))))
;;;;;
(define (scale-list items factor)
  (if (null? items)
      '()
      (cons (* factor (car items))
	    (scale-list (cdr items) factor))))
;;2.21
(define (square-list items)
  (map  square items))
(define (square x) (* x x))
;;;2.22
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
	answer
	(iter (cdr things)
		   (cons (square (car things))
			 answer))))
  (reverse (iter items '())))
;;;;;2.23
(define (for-each f items)
  (cond ((not (null? items))
	 (f (car items))
	(for-each f (cdr items)))))
;;;;;2.2.2
(define (count-leaves x)
  (cond ((null? x) 0)
	((not (pair? x)) 1)
	(else
	 (+ (count-leaves (car x))
	    (count-leaves (cdr x))))))
;(define x (cons (list 1 2) (list 3 4)))
;;;2.26
;(define x (list 1 2 3))
;(define y (list 4 5 6))
;;;2.27
;(define x (list (list 1 2) (list 3 4)))
(define x (list (list 1 2) (list 3 4) (list 5 6)))
(define (deep-reverse list)
  (define (iter remained result)
    (if (null? remained)
	result
	(if (not (pair? (car remained)))
	    (iter (cdr remained)
		  (cons (car remained) result))
	    (iter (cdr remained)
		  (cons (iter (car remained) '() )
			result)))))
  (iter list '()))
;;;;;2.28
(define (frigne items)
  (define (iter things result)
    (cond ((null? things) result)
	  ((not (pair? things)) (append result (list things)))
	  (else
	   (iter (cdr things) (iter (car things) result)))))
  (iter items '()))
;; (define (fringe tree)
;;   (define (empty-tree? tree) (null? tree))
;;   (define (leaf? tree) (not (pair? tree)))
;;   (define (left-branch tree) (car tree))
;;   (define (right-branch tree) (cdr tree))
;;   (cond ((empyt-tree? tree)
;; 	 '())
;; 	((leaf? tree)
;; 	 (list tree))
;; 	(else
;; 	 (append (fringe (left-branch tree))
;; 		 (fringe (right-branch tree))))))

;;;2.29
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cadr branch))
(define (total-weight mobile)
  (define (branch-weight branch)
    (if (hangs-another-mobile? branch)
	(total-weight (branch-structure branch))
	(branch-structure branch)))
  (define (hangs-another-mobile? branch)
    (pair? (branch-structure branch)))
  (+ (branch-weight (left-branch mobile))
     (branch-weight (right-branch mobile))))
;;;;;
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
	 (if (pair? sub-tree)
	     (scale-tree sub-tree factor)
	     (* sub-tree factor)))
       tree))
;;;2.30
(define (square-tree tree)
  (map (lambda (sub-tree)
	 (if (pair? sub-tree)
	     (square-tree sub-tree)
	     (square sub-tree)))
       tree))
;;;;2.31
(define (tree-map f tree)
  (map (lambda (sub-tree)
	 (if (pair? sub-tree)
	     (tree-map f sub-tree)
	     (f sub-tree)))
       tree))
;;;;;2.32
(define  (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
	(append  rest (map (lambda (x)
			     (cons (car s) x))
			   rest)))))
